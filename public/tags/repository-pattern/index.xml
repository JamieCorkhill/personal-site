<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>repository-pattern on Jamie Corkhill</title>
    <link>/tags/repository-pattern/</link>
    <description>Recent content in repository-pattern on Jamie Corkhill</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 14 Oct 2020 11:10:54 -0500</lastBuildDate>
    
	<atom:link href="/tags/repository-pattern/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Understanding Typescript Generics</title>
      <link>/2020/10/understanding-typescript-generics/</link>
      <pubDate>Wed, 14 Oct 2020 11:10:54 -0500</pubDate>
      
      <guid>/2020/10/understanding-typescript-generics/</guid>
      <description>This article was first written for Smashing Magazine on October 10th, 2020. You can find it here.
 Introduction In this article, we’ll be learning the concept of Generics in TypeScript and examining how Generics can be used to write modular, decoupled, and reusable code. Along the way, we’ll briefly discuss how they fit into better testing patterns, approaches to error handling, and domain/data-access separation.
A Real-World Example I want to enter into the world of Generics not by explaining what they are, but rather by providing an intuitive example for why they are useful.</description>
    </item>
    
  </channel>
</rss>